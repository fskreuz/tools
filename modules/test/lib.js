const e=()=>{},t=[],s=class extends Error{constructor(e,...t){super(...t),this.result=e}},r={name:"Test Defaults",run:!0,expectSuccess:!0,getMessage:(e,t)=>`${e} ${t}`,callback:e},n={run:!0,expectSuccess:!0,getMessage:(e,t)=>`${e} ${t}`},c={run:!0,expectSuccess:!1,getMessage:(e,t)=>`${e} # TODO ${t}`},o={run:!1,expectSuccess:!1,getMessage:(e,t)=>`${e} # SKIP ${t}`},a=({actual:e,expected:t,stack:s})=>{const r=[];return r.push(`Actual:\n\n${JSON.stringify(e,null,2)}`),r.push(`Expected:\n\n${JSON.stringify(t,null,2)}`),s&&r.push(`Stack:\n\n${s}`),r.join("\n\n").replace(/^(.*)/gm,"# $1")},u=(s,c=e)=>{t.push({...r,...n,name:s,callback:c})},i=(s,n=e)=>{t.push({...r,...c,name:s,callback:n})},l=(s,n=e)=>{t.push({...r,...o,name:s,callback:n})};setTimeout((async()=>{try{const e=await(async e=>{let t=!1;const r=[];r.push("TAP version 13"),r.push(`1..${e.length}`);for(const[s,n]of e.entries()){const e=n.getMessage(s+1,n.name);if(n.run)try{await Promise.race([n.callback(),new Promise(((e,t)=>{setTimeout((()=>{t(new Error("Test timed out."))}),3e3)}))]),r.push(`ok ${e}`)}catch(s){r.push(`not ok ${e}\n${a(s)}`),n.expectSuccess&&(t=!0)}else r.push(`ok ${e}`)}if(t)throw new s(r.join("\n"),"Test failed");return r.join("\n")})(t);console.log(e)}catch(e){console.warn(e.result),process&&(process.exitCode=1)}}));const p=()=>!0,f=(e,t)=>Object.is(e,t),h=(e,t)=>{if(Object.is(e,t))return!0;if(e instanceof Date&&t instanceof Date)return e.getTime()===t.getTime();if(!e||!t||"object"!=typeof e&&"object"!=typeof t)return Object.is(e,t);if(e.prototype!==t.prototype)return!1;const s=Object.entries(e).sort(((e,t)=>e[0].localeCompare(t[0]))),r=Object.entries(t).sort(((e,t)=>e[0].localeCompare(t[0])));return s.length===r.length&&(!!r.every(((e,t)=>s[t][0]===e[0]))&&(!!r.every(((e,t)=>h(s[t][1],e[1])))&&Object.is(typeof e,typeof t)))};const m=(e,t)=>!!(Error.prototype.isPrototypeOf.call(Error,t)&&e instanceof t)||(!!(t instanceof RegExp&&t.test(e.message))||("string"==typeof t&&e.message===t||!("function"!=typeof t||function(e){try{Reflect.construct(String,[],e)}catch(e){return!1}return!0}(t)||!t(e)))),g=class extends Error{constructor(e,t,...s){super(...s),this.expected=t,this.actual=e}},y=(e,t,s,r="Assertion must pass.")=>{if(!e)throw new g(t,s,r)},b=(e,t="Value must be truthy.")=>{y(!!e,e,!0,t)},w=(e,t="Value must be falsy.")=>{y(!e,e,!1,t)},$=(e,t,s="Value must be equal")=>{y(f(e,t),e,t,s)},j=(e,t,s="Value must not be equal")=>{y(!f(e,t),e,t,s)},x=(e,t,s="Value must be deep equal")=>{y(h(e,t),e,t,s)},d=(e,t,s="Value must not be deep equal")=>{y(!h(e,t),e,t,s)},O=(e,t=p,s="Operation must throw an error")=>{try{e()}catch(e){if(m(e,t))return}throw new g("Error thrown","No error thrown",s)},k=async(e,t=p,s="Promise must reject")=>{try{await e}catch(e){if(m(e,t))return}throw new g("Promise rejected","Promise not rejected",s)};export{g as AssertionError,y as assert,x as deepEqual,$ as equal,d as notDeepEqual,j as notEqual,w as notOk,b as ok,k as rejects,l as skip,u as test,O as throws,i as todo};
//# sourceMappingURL=lib.js.map
