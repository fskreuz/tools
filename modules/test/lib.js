const e=()=>{},t=[],s=class extends Error{constructor(e,...t){super(...t),this.result=e}},r={run:!0,expectSuccess:!0,getMessage:(e,t,s)=>`${e} ${t} - ${s}`},n={run:!0,expectSuccess:!1,getMessage:(e,t,s)=>`${e} # TODO ${t} - ${s}`},c={run:!1,expectSuccess:!1,getMessage:(e,t,s)=>`${e} # SKIP ${t} - ${s}`},o=({actual:e,expected:t,stack:s})=>{const r=[];return r.push(`Actual:\n\n${JSON.stringify(e,null,2)}`),r.push(`Expected:\n\n${JSON.stringify(t,null,2)}`),s&&r.push(`Stack:\n\n${s}`),r.join("\n\n").replace(/^(.*)/gm,"# $1")},a=s=>{const o={name:"Test Defaults",run:!0,expectSuccess:!0,getMessage:(e,t,s)=>`${e} ${t} - ${s}`,callback:e},a={name:s,tests:[]};return t.push(a),{test:(t,s=e)=>{a.tests.push({...o,...r,callback:s,name:t})},todo:(t,s=e)=>{a.tests.push({...o,...n,callback:s,name:t})},skip:(t,s=e)=>{a.tests.push({...o,...c,callback:s,name:t})}}};setTimeout((async()=>{try{const e=await(async e=>{const t=e.reduce(((e,t)=>e+t.tests.length),0);let r=0,n=!1;const c=[];c.push("TAP version 13"),c.push(`1..${t}`);for(const t of e)for(const e of t.tests){r+=1;const s=e.getMessage(r,t.name,e.name);if(e.run)try{await e.callback(),c.push(`ok ${s}`)}catch(t){c.push(`not ok ${s}\n${o(t)}`),e.expectSuccess&&(n=!0)}else c.push(`ok ${s}`)}if(n)throw new s(c.join("\n"),"Test failed");return c.join("\n")})(t);console.log(e)}catch(e){console.warn(e.result),process&&(process.exitCode=1)}}));const u=()=>!0,l=(e,t)=>Object.is(e,t),i=(e,t)=>{if(Object.is(e,t))return!0;if(e instanceof Date&&t instanceof Date)return e.getTime()===t.getTime();if(!e||!t||"object"!=typeof e&&"object"!=typeof t)return Object.is(e,t);if(e.prototype!==t.prototype)return!1;const s=Object.entries(e).sort(((e,t)=>e[0].localeCompare(t[0]))),r=Object.entries(t).sort(((e,t)=>e[0].localeCompare(t[0])));return s.length===r.length&&(!!r.every(((e,t)=>s[t][0]===e[0]))&&(!!r.every(((e,t)=>i(s[t][1],e[1])))&&Object.is(typeof e,typeof t)))};const p=(e,t)=>!!(Error.prototype.isPrototypeOf.call(Error,t)&&e instanceof t)||(!!(t instanceof RegExp&&t.test(e.message))||("string"==typeof t&&e.message===t||!("function"!=typeof t||function(e){try{Reflect.construct(String,[],e)}catch(e){return!1}return!0}(t)||!t(e)))),f=class extends Error{constructor(e,t,...s){super(...s),this.expected=t,this.actual=e}},h=(e,t,s,r="Assertion must pass.")=>{if(!e)throw new f(t,s,r)},m=(e,t="Value must be truthy.")=>{h(!!e,e,!0,t)},g=(e,t="Value must be falsy.")=>{h(!e,e,!1,t)},y=(e,t,s="Value must be equal")=>{h(l(e,t),e,t,s)},$=(e,t,s="Value must not be equal")=>{h(!l(e,t),e,t,s)},b=(e,t,s="Value must be deep equal")=>{h(i(e,t),e,t,s)},w=(e,t,s="Value must not be deep equal")=>{h(!i(e,t),e,t,s)},j=(e,t=u,s="Operation must throw an error")=>{try{e()}catch(e){if(p(e,t))return}throw new f("Error thrown","No error thrown",s)},d=async(e,t=u,s="Promise must reject")=>{try{await e}catch(e){if(p(e,t))return}throw new f("Promise rejected","Promise not rejected",s)};export{f as AssertionError,h as assert,b as deepEqual,y as equal,a as module,w as notDeepEqual,$ as notEqual,g as notOk,m as ok,d as rejects,j as throws};
//# sourceMappingURL=lib.js.map
